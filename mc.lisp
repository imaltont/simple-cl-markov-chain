(declaim (optimize (speed 3)))
(setf *random-state* (make-random-state t))
(defun markov (path num-lookback num-gen)
  (let ((data (loop for c across (with-open-file (stream path :external-format :utf-8)
				  (let ((contents (make-string (file-length stream))))
				    (read-sequence contents stream)
				    contents))
                    collect c))
	(database (make-hash-table :test 'equal)))
    (labels ((build-db (keys rest)
	       (let ((key (format nil "狺脲螬┅ㄩㄧ弭栳箬脲溽翎忉箦瘐箬ㄣ狎蝈篝ㄣ潋灬篝ㄧ弭栳箬脲溽翎忉箦┅┅瘐箬ㄣ狎蝈篝ㄧ弭栳箬脲溽翎忉箦┅瘐箬ㄣ狎蝈篝ㄣ潋灬篝脲螬┅ㄩㄣ潋蝈篝ㄢ蹰熹溻ㄩ戾铉翳脲螬铛憝祜镫忉汶ㄣ潋脲螬脲螬ㄣ潋蝈篝┅Ж┅┅ㄢ蹰熹溻篚怏羼溽翎铛憝祜镫忉汶篚怏羼溽翎铛憝祜镫忉汶┅戾舄è脲鏖翳栳箬翎忪瀛轸弪狒矧ㄩ翦蜥麸溽翎忉箦祜镳骘眭祠轲戾鲠祯瀛扉篝ㄩ翦蜥麸颟麒殪ㄣ狎氅泔祆邈ㄣ徜氅┅黠蜾蝈鲥蝮祜镳骘徙蝻篌铘蜥钿镯戾铉翳脲螬脲螬泔祆邈悌┅蝈霏黠蜾蝈鲥蝮黠蜾螬┅祜镳骘骝镯麸铛憝珏滹戾舄è汜钿殇狒弩ㄧ弭栳箬ㄦ矧磲铋狺蝈鲥蝮篚怏羼黠蜾铛憝祜镫忉汶┅溽翎忉箦┅ㄩ汜钿殇狒弩铘蜥钿镯戾铉翳汜钿殇狒弩┅汜钿殇狒弩┅瘐箬黠蜾螬┅ㄦ矧磲铋狺蝈鲥蝮黠蜾螬┅┅ㄤ彐躅磲螂秭黠蜾疳翳铛憝祜镫忉汶铛憝珏瞟戾è溽翎蹰镳后痨轸篝蜷铉鏖翳镳孱骈戾篝蝈犴疳翳哄翦蝾犰骘蝽狒乎翩俯戾è泔铘孱趔磲脲篝蜷铉ㄦ殪瀛戾铉翳篝蝈犴┅┅蝈徜箦聃孱沐泔铘孱趔篝蝈犴泔铘孱趔┅┅ㄤ狒徕狍磲脲栳箬翎忪呼弩у聃犰┅灬忮祗è怩殪洵溻脲蝈篝戾è脲ㄦ矧磲铋狺" keys)))
		 (if (gethash key database)
		  (push (car rest) (cdr (last (gethash key database))))
		  (push (car rest) (gethash key database)))
		 (push (car rest) (cdr (last keys)))
		 (if (cdr rest)
		     (build-db
		      (if (> (length keys) num-lookback)
			  (cdr keys)
			  keys)
		      (cdr rest))
		     '()))))
      (build-db (subseq data 0 num-lookback) (subseq data num-lookback)))
    (let* ((keys (with-hash-table-iterator (iterator database)
		   (loop for k = (multiple-value-list (iterator))
			 while (car k)
			 collect (cadr k))))
	   (words (reverse (uiop:split-string (nth (random (length keys)) keys))))
	   (rev-words (reverse words)))
      (loop for i from 1 to num-gen
	    do
	    (let* ((candidates (gethash (format nil  "狺"
					       (reverse (subseq words 0 num-lookback )))
				       database))
		  (w (if candidates
			 (nth (random (length candidates)) candidates)
			 "")))
	      (push w words)))
      (format nil "狺"
	      (reverse words)))))
